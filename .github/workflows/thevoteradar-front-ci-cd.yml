name: CI/CD Pipeline - thevoteradar-front

on:
  push:
    branches: [ main, dev ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - prod

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: package-lock.json

    - name: ğŸ”‘ Authenticate to GCP
      uses: google-github-actions/auth@v2
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: â˜ï¸ Setup gcloud
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ vars.GCP_PROJECT_ID }}

    - name: âœ… Verify gcloud auth
      run: |
        gcloud auth list
        gcloud config list project
        echo "âœ… Authenticated successfully"

    - name: ğŸ³ Configure Docker for GCR
      run: gcloud auth configure-docker --quiet

    - name: ğŸ“¦ Install dependencies
      run: npm ci --no-audit --no-fund

    - name: ğŸ” Generate environment file from Secrets Manager
      run: |
        SECRET_PREFIX="thevoteradar"
        
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          ENV_FILE="environment.prod.ts"
          ENV_SUFFIX="prod"
          PRODUCTION="true"
          DEVELOPMENT="false"
          echo "ğŸ”´ PRODUCTION environment detected"
        else
          # Para dev tambiÃ©n generamos environment.prod.ts porque el Dockerfile usa --configuration production
          ENV_FILE="environment.prod.ts"
          ENV_SUFFIX="dev"
          PRODUCTION="false"
          DEVELOPMENT="true"
          echo "ğŸŸ¢ DEVELOPMENT environment detected (usando environment.prod.ts para build de producciÃ³n)"
        fi
        
        KEY1_SECRET="$SECRET_PREFIX-key1-$ENV_SUFFIX:latest"
        KEY2_SECRET="$SECRET_PREFIX-key2-$ENV_SUFFIX:latest"
        KEY3_SECRET="$SECRET_PREFIX-key3-$ENV_SUFFIX:latest"
        KEY4_SECRET="$SECRET_PREFIX-key4-$ENV_SUFFIX:latest"
        API_URL_SECRET="$SECRET_PREFIX-api-url-$ENV_SUFFIX:latest"
        BACKOFFICE_API_URL_SECRET="$SECRET_PREFIX-backoffice-api-url-$ENV_SUFFIX:latest"
        SURVEY_API_URL_SECRET="$SECRET_PREFIX-survey-api-url-$ENV_SUFFIX:latest"
        DEFAULT_TENANT_ID_SECRET="$SECRET_PREFIX-default-tenant-id-$ENV_SUFFIX:latest"
        POWER_BI_URL_SECRET="$SECRET_PREFIX-powerbi-url-$ENV_SUFFIX:latest"
        
        echo "ğŸ“‹ Reading secrets from GCP Secret Manager..."
        KEY1=$(gcloud secrets versions access $KEY1_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '')
        KEY2=$(gcloud secrets versions access $KEY2_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '')
        KEY3=$(gcloud secrets versions access $KEY3_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '')
        KEY4=$(gcloud secrets versions access $KEY4_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '')
        API_URL=$(gcloud secrets versions access $API_URL_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '')
        BACKOFFICE_API_URL=$(gcloud secrets versions access $BACKOFFICE_API_URL_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '')
        SURVEY_API_URL=$(gcloud secrets versions access $SURVEY_API_URL_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '')
        DEFAULT_TENANT_ID=$(gcloud secrets versions access $DEFAULT_TENANT_ID_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '475711')
        POWER_BI_URL=$(gcloud secrets versions access $POWER_BI_URL_SECRET --project=${{ vars.GCP_PROJECT_ID }} 2>/dev/null || echo '')
        
        if [ -z "$KEY1" ] || [ -z "$KEY2" ] || [ -z "$KEY3" ] || [ -z "$KEY4" ]; then
          echo "âš ï¸ Warning: Some encryption keys are missing from Secrets Manager"
          echo "âš ï¸ Environment: $ENV_SUFFIX"
          echo "âš ï¸ Missing secrets will use empty values. Please configure secrets in GCP Secret Manager"
        else
          echo "âœ… All encryption keys retrieved successfully"
        fi
        
        if [ -z "$API_URL" ] || [ -z "$BACKOFFICE_API_URL" ] || [ -z "$SURVEY_API_URL" ] || [ -z "$POWER_BI_URL" ]; then
          echo "âš ï¸ Warning: Some URL secrets are missing from Secrets Manager"
          echo "âš ï¸ Environment: $ENV_SUFFIX"
        fi
        
        # Asegurar que el directorio existe
        mkdir -p src/environments
        
        # Generar el contenido del environment
        ENV_CONTENT=$(printf "export const environment = {\n  production: %s,\n  development: %s,\n  apiURL: '%s',\n  backofficeApiURL: '%s',\n  surveyApiURL: '%s',\n  defaultTenantId: '%s',\n  key1: '%s',\n  key2: '%s',\n  key3: '%s',\n  key4: '%s',\n  powerBiURL: '%s',\n};\n" \
          "$PRODUCTION" "$DEVELOPMENT" "$API_URL" "$BACKOFFICE_API_URL" "$SURVEY_API_URL" "$DEFAULT_TENANT_ID" "$KEY1" "$KEY2" "$KEY3" "$KEY4" "$POWER_BI_URL")
        
        # Angular necesita environment.ts para hacer el reemplazo segÃºn la configuraciÃ³n
        # Generamos environment.ts como base y el archivo correspondiente segÃºn el entorno
        echo "$ENV_CONTENT" > src/environments/environment.ts
        
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          # Para producciÃ³n, generamos environment.prod.ts
          echo "$ENV_CONTENT" > src/environments/environment.prod.ts
          echo "âœ… Environment files generated: environment.ts and environment.prod.ts for $ENV_SUFFIX environment"
        else
          # Para desarrollo, generamos environment.development.ts (con development: true)
          # y tambiÃ©n environment.prod.ts con el mismo contenido (porque el Dockerfile usa --configuration production)
          echo "$ENV_CONTENT" > src/environments/environment.development.ts
          echo "$ENV_CONTENT" > src/environments/environment.prod.ts
          echo "âœ… Environment files generated: environment.ts, environment.development.ts and environment.prod.ts for $ENV_SUFFIX environment"
          echo "â„¹ï¸ Note: Dockerfile uses --configuration production, so environment.prod.ts will be used in the build"
          echo "â„¹ï¸ For local development with ng serve, use --configuration development to use environment.development.ts"
        fi
        
        echo "ğŸ“„ Verifying files exist:"
        ls -la src/environments/environment*.ts || echo "âš ï¸ Files not found!"

    - name: ğŸ§ª Run tests (if available)
      run: |
        if npm run | grep -q "test"; then
          npm test -- --watch=false --browsers=ChromeHeadless
        else
          echo "No tests configured, skipping..."
        fi
      continue-on-error: true

    - name: ğŸ³ Build & Push Docker image
      run: |
        # Determinar el tag y servicio segÃºn la rama
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          TAG="prod-${{ github.sha }}"
          SERVICE_NAME="thevoteradar-front-prod"
          ENVIRONMENT="production"
        else
          TAG="dev-${{ github.sha }}"
          SERVICE_NAME="thevoteradar-front-dev"
          ENVIRONMENT="development"
        fi

        echo "Building image: gcr.io/${{ vars.GCP_PROJECT_ID }}/thevoteradar-front:$TAG"
        echo "Deploying service: $SERVICE_NAME in $ENVIRONMENT"

        docker build -t gcr.io/${{ vars.GCP_PROJECT_ID }}/thevoteradar-front:$TAG .
        docker push gcr.io/${{ vars.GCP_PROJECT_ID }}/thevoteradar-front:$TAG

        # Exportar a env para siguientes pasos
        echo "TAG=$TAG" >> $GITHUB_ENV
        echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
        echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV

    - name: ğŸš€ Deploy to Cloud Run
      run: |
        gcloud run deploy $SERVICE_NAME \
          --image gcr.io/${{ vars.GCP_PROJECT_ID }}/thevoteradar-front:$TAG \
          --region ${{ vars.GCP_REGION }} \
          --platform managed \
          --allow-unauthenticated \
          --port 8080 \
          --memory=512Mi \
          --cpu=1 \
          --max-instances=10 \
          --min-instances=1 \
          --concurrency=80 \
          --timeout=300s

    - name: ğŸ“¡ Get service URL and health check
      run: |
        # Esperar un momento para que el servicio se inicie
        echo "â³ Esperando que el servicio se inicie..."
        sleep 15
        
        # Obtener la URL real del servicio desplegado
        SERVICE_URL=$(gcloud run services describe $SERVICE_NAME \
          --project ${{ vars.GCP_PROJECT_ID }} \
          --region ${{ vars.GCP_REGION }} \
          --format="value(status.url)")
        
        echo "âœ… Deployment completed!"
        echo "ğŸ”— URL del servicio: $SERVICE_URL"
        echo "ğŸ·ï¸ Image tag: $TAG"
        echo "ğŸ”§ Environment: $ENVIRONMENT"
        
        # Hacer health check
        echo "ğŸ¥ Ejecutando health check..."
        curl -f "$SERVICE_URL" || {
          echo "âš ï¸ Health check fallÃ³, pero el servicio puede estar iniciÃ¡ndose..."
          echo "ğŸ”„ Reintentando en 15 segundos..."
          sleep 15
          curl -f "$SERVICE_URL" || {
            echo "âŒ Health check fallÃ³ despuÃ©s del segundo intento"
            echo "â„¹ï¸ El servicio puede estar funcionando, pero el health check no respondiÃ³"
            exit 1
          }
        }
        
        echo "âœ… Health check exitoso"
        echo "ğŸ‰ Deploy completado - thevoteradar-front $ENVIRONMENT estÃ¡ en lÃ­nea"

